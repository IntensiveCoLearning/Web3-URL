# Web3 URL 残酷共学第 1 期残酷指引

> ⚠️ 正式开始前请确保你在身体上和精神上都处于合适的状态，请刻意练习，残酷面对 🆒。为方便检索 The First Web3 URL Intensive CoLearning 简写为 WICL1st，第 2 期即为WICL2nd，第 3 期即为 WICL3rd，以此类推。

> ⚠️ 报名需要按要求认真填写下面 [ XXX ] 部分，方可通过报名审核，通过审核即可开始自主学习。

---

# [ 你的名字 ]

1. **自我介绍：**

   wayhome, IT 老兵一枚，什么都懂一点儿，对 Web3 一直略有了解，但没有特意学习过，希望能借这个机会系统学习下

2. **组队期待：**


   对 Defi 方向的项目比较感兴趣


3. **你认为你会完成本次 Web3 URL 的残酷学习吗？**

   Maybe 60%

---

## 第 1 期共学时间计划

- **7 月 8 日 - 7 月 14 日**：

  - 自我介绍：大家按要求更新上方自我介绍，方面大家互相了解，及后续自由组队方向。

  -  [Web3 URL 残酷共学频道](https://t.me/LXDAO/8748)报道：大家可以自由在残酷共学群里交流分享，互动答疑，根据自身学习阶段情况随时开启自由组队。

  - 课前学习：了解残酷共学流程，GitHub 协作共学基础；Web3:// 协议课前学习。

- **7 月 15 日 - 7 月 21 日**：

  - **7 月 15 日 周一晚 8 点- 9 点（北京时间）：** 第 1 次公开课分享
  - **本周共学内容：** 涉及 Web3://  的背景和演进历史；支持 Web3://  协议的访问方式 (gateway 和 EVM browser)来浏览以太坊上面的数据；熟悉使用 Web3://  和 EthStorage 早期测试网来部署简单的去中心化网站。
  - **Homework1：** 见[课程 PPT](https://docs.google.com/presentation/d/1egJUKJrjC9wjkmOF9sLBkTSwHpd6hl8FXkWehPW7kFk/edit#slide=id.g1754f50a55c_0_11)。

- **7 月 22 日 - 7 月 28 日**
  - **7 月 22 日 周一晚 8 点- 9 点（北京时间）：** 第 2 次公开课分享

  - **本周共学内容：** 涉及 Web3://  高级开发工具，包括：在命令行通过 web3curl 来通过 Web3://  协议下载数据，通过 ethfs-uploader 批量上传网页数据，通过 manual 模式来搭建去中心化多人交互全链网站；及深入理解以太坊的存储模型和 gas 开销等。
  - **边学边用实战开发：** 根据组队情况自由安排。
  - **Homework2：** 见[课程 PPT](https://docs.google.com/presentation/d/1egJUKJrjC9wjkmOF9sLBkTSwHpd6hl8FXkWehPW7kFk/edit#slide=id.g1754f50a55c_0_11)。

- **7 月 29 日 - 8 月 4 日**
  - **7 月 29 日 周一晚 8 点- 9 点（北京时间）：** 第 3 次公开课分享
  - **本周共学内容：** 涉及实际应用案例分享及未来以太坊基础设施在 Web3://  的重要作用及开发方向等。
  - **边学边用实战开发：** 根据组队情况自由安排。
  - **结营分享：** 具体时间及详情另在「Web3 URL 残酷共学频道」通知。

---

## 笔记证明 Notes Proof
<!-- Content_START --> 
### 07.15

- 今日学习时间：1h
- 学习内容小结：
  * 阅读 eip-4804 和 web3 url docs
    - web3 url 为以太坊上的资源定义唯一标识，类似亚马逊的 arn 定义唯一标识 aws 资源
    - 提供 http 的兼容，以方便现有 web2 用户最低成本迁移，类似于一种 web 2.5 的方案
    - 缺乏对安全性的考虑
    - 工作原理
      ![img](https://web3url.io/img/work.e14cc70c.png)
- Homework 部分（如果有安排需要填写证明完成）
- Question and Ideas（有什么疑问/或者想法，可以记在这里，也可以分享到共学频道群讨论交流）



### 07.16

- 今日学习时间：1h
- 学习内容小结:
  *  阅读 eip-6860 和 web3 url docs
    - web3 url 的基本形式 `web3URL         = schema "://" [ userinfo "@" ] contractName [ ":" chainid ] pathQuery`
        - userinfo 表示调用 EVM 的用户，即 EVM 调用消息中的“From”字段
        - contractName 表示要调用的合约，即 EVM 调用消息中的“To”字段
            - 如果是一个地址，则将其用于“To”字段
            - 否则则是来自域名服务的域名，必须解析为一个地址才能用于“To”字段
        - chainid 指示要解析 contractName 并调用消息的链
        - 自动模式下的 path 格式:  `/<methodName>/<methodArg1>/<methodArg2>/...[?returns=(<type1>,<type2>,...)]`
            - `<methodName>` 是要调用的函数方法的名称
            - `methodArg` 是具有 `[<type>!]<value>` 语法的方法的一个参数
            - `?returns=` 指定方法返回签名
    - web3 客户端
        - https 网关
        - evm 浏览器
        - chrome 插件
        - web3 沙箱
        - web3curl 类似 curl 的命令行

### 07.17

- 今日学习时间: 1h
- 学习内容小结:
   * 通过 hackquest 学习以太坊基础内容
     - 以太坊被视作一个“**状态机**”，通过智能合约的代码更新其状态。执行这些智能合约代码，需要消耗以太币（ether），而这个过程是通过一种名为“权益证明”（Proof of Stake, PoS）的共识机制进行验证并在整个网络中广播同步的。

      以太坊中，主要有两种类型的账户：外部拥有账户（Externally Owned Accounts, EOAs）和合约账户（Contract Accounts）
      
      **账户字段**
      
      - **Nonce**：用于记录外部账户发起的交易数量或合约账户创建的合约数量。外部账户的 nonce 从0开始计数，合约账户的 nonce 从1开始。
      - **Balance**：账户拥有的以太币数量，以Wei为单位（1 ETH = 1e+18 Wei）
      - **CodeHash**：合约账户的 EVM 代码的哈希值。对于合约账户，CodeHash代表可执行的智能合约代码，该代码在账户接收到消息调用时执行. 对于外部账户，此字段为空字符串的哈希。
      - **StorageRoot:  编码了账户的存储内容,**
      
      以太坊是一个巨大的、全球分布式的“状态机”。这里，"状态"指的是在任何给定时刻，整个以太坊网络的具体信息快照。
      
      通过仅在区块头中存储根哈希值，以太坊能够确保数据的完整性和不可篡改性，因为任何对数据的微小更改都会导致根哈希值的变化，从而被网络检测到.而在节点本地存储完整树的数据，则允许各节点独立地验证和更新状态，进一步加强了网络的去中心化特性
      
      以太坊上的交易包含了一系列字段：
      
      - from - 发送者的地址，该地址将签署交易。 这将是一个外部帐户，因为合约帐户不能发送交易。
      - recipient – 接收地址（如果是外部帐户，交易将传输值。 如果是合约帐户，交易将执行合约代码）
      - signature – 发送者的标识符。 当发送者的私钥签署交易并确保发送者已授权此交易时，生成此签名。
      - nonce - 一个有序递增的计数器，表示来自帐户的交易数量
      - value – 发送者向接收者转移的以太币数量（面值为 WEI，1 个以太币 = 1e+18wei）
      - input data – 可包括任意数据的可选字段
      - gasLimit – 交易可以消耗的最大数量的燃料单位。 以太坊虚拟机指定每个计算步骤所需的燃料单位
      - maxPriorityFeePerGas - 作为小费提供给验证者的已消耗燃料的最高价格
      - maxFeePerGas - 愿意为交易支付的每单位燃料的最高费用（包括 baseFeePerGas 和 maxPriorityFeePerGas）
      
      以太坊有几种不同类型的交易：
      
      - 常规交易：从一个帐户到另一个帐户的交易。
      - 合约部署交易：没有“to”地址的交易，数据字段用于合约代码。
      - 执行合约：与已部署的智能合约进行交互的交易。 在这种情况下，“to”地址是智能合约地址
      
      **交易的生命周期**
      
      - **创建和签名**
      - **广播**：签名的交易被广播到以太坊网络
      - **打包和验证**： 矿工会从交易池中选择要包含在下一个区块中的交易
      - **执行**：一旦交易被打包进区块并被网络确认，交易将被执行
      - **最终确认**：随着更多区块被挖掘并附加到区块链上，交易获得更多确认
    
   - 明日计划： 学习智能合约和 EVM

### 07.18


- 今日学习时间：1h
- 学习内容小结：
   - 智能合约是运行在以太坊链上，位于以太坊区块链上一个**特定地址**的自动执行、控制或文档化法律或逻辑行为的**代码（函数）**和**数据（状态）**

      在以太坊上，智能合约是以 EVM 字节码的形式存储的
      
      EVM 是以太坊的运行环境，是一个基于堆栈的虚拟机，它是分布式的，运行在以太坊网络中的每个节点上
      
      智能合约的运行：
      
      1. **编写和编译**
      2. **部署**
      3. **执行**
      4. **状态变更**
      5. **Gas消耗**
      
      基于 solidity Hello world 版本的 合约

      ```jsx
      // 指定Solidity的版本
      pragma solidity ^0.8.0;
      
      // 定义一个合约，名为'HelloWorld'
      contract HelloWorld {
          // 定义一个状态变量，用于存储一个字符串
          string public greeting = "Hello, World!";
      
          // 定义一个函数，用于改变'greeting'变量的值
          function setGreeting(string memory _greeting) public {
              greeting = _greeting;
          }
      
          // 定义一个函数，用于获取当前的'greeting'值
          function getGreeting() public view returns (string memory) {
              return greeting;
          }
      }
      ```
      
      pragma是一个用于指定编译器版本的关键字。它的作用是确保代码能够在特定版本的编译器下正确编译和执行，以避免潜在的兼容性问题。
      
      使用关键字 contract 定义合约，一个 Solidity 的 **.sol** 文件可以包含一个或多个 contract。
      
      对于合约的命名，我们建议遵循“大驼峰”的命名规范，“大驼峰”是指每个单词的首字母都大写，例如：MyContract

### 07.19


- 今日学习时间：1h
- 学习内容小结：
        public 函数通常需要更多的燃气（ gas ）来执行，因为它们需要处理许多安全性和访问控制检查。通过将某些非必要公开函数标记为 private ，可以减少合约执行时的燃气成本，从而提高效率。
      
      要定义一个仅在合约内部，以及继承它的合约中才能使用的函数，我们使用关键字 internal，并将其放在*函数* 参数之后。
      
      要定义一个外部用户或其他合约能使用的*函数*，我们使用关键字 external，并将其放在*函数* 参数之后。在本合约中使用时必须加上this关键词。`exernal`  不能用于定义变量。
      
      接口合约中的*函数*都必须是 external 的。
      
      状态变量是一种**永久**存在于区块链上的变量。如果这个信息应该被记录在区块链上，则将其设置为状态变量。状态变量通常需要更多的 gas 来读写，所以应当仅在必要时使用。
      
      gas用于衡量执行智能合约操作所需的计算资源。
      
      纯函数— pure，所谓纯函数就是该函数不会访问以及修改任何状态变量。一般来讲 pure 函数用于返回一个固定的值或完成计算。 使用 pure 定义的函数被调用时不用花费 gas，并且可以保证该函数不会改变状态变量，有益于开发时的模块化管理。
      
      view 函数不会修改状态变量，但可能使用（读取）状态变量，而 pure 函数甚至不会读取状态变量。如果一个函数是*pure*函数，则同时它也是一个*view*函数。
      
      *地址*是以太坊区块链上账户或智能合约的唯一标识符。地址占20个字节，一个字节有8个 bit ,所以地址共有160个 *bit*，一个字节需要两个十六进制数表示，所以需要40个十六进制数表示一个地址。
      
      `*在以太坊中，每个地址都有一个成员变量，即地址的余额balance`.`余额以 uint 形式存在，因为它永远不可能为负值`*
      
      在 solidity 中，只能对申明为 payable 的地址进行转账。
      
      构造函数是在合约部署时自动调用且只被调用一次的函数。
      
      为什么需要构造函数？
      
      有两个原因：
      
      1.**访问控制**。例如，我们想要发行自己的代币，并且我想定义只有我才能铸造代币。我们可以通过构造函数在部署时设置——谁部署了合约，谁就是所有者。
      
      2.**确保合约正确的初始化**。因为一旦合约部署上链，所有人即可和合约交互，因此我们需要通过构造函数来保证合约部署后所有需要初始化的变量都已经正确的初始化。
      
      *require* 顾名思义，是一种类似于断言的语法，如果 *require* 当中的条件没有满足，此次调用将会失败。solidity 暂不支持中文编码，错误信息请用英文编写。
      
      msg.sender可以获取本次调用的调用者地址。
      
      msg.sender与tx.origin的区别
      
      - 可以想象一个场景，我这个用户调用了函数A，则A又调用了B，B又调用了C。A，B，C是三个不同合约中的函数。我的钱包地址为0x123。对于函数C，msg.sender是函数B的合约地址，而tx.origin则是0x123，也就是我的钱包地址，因为tx.origin表示最初初始化整个调用链的账户地址。

### 07.20


- 今日学习时间：1h
- 学习内容小结：
      搭建 solidity 的开发环境，部署 hello world
<!-- Content_END -->
